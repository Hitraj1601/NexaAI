// Performance monitoring utilities for tracking app performance\nimport { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';\n\n// Types for performance metrics\ninterface PerformanceMetric {\n  name: string;\n  value: number;\n  delta: number;\n  id: string;\n  rating: 'good' | 'needs-improvement' | 'poor';\n}\n\ninterface PerformanceData {\n  url: string;\n  timestamp: number;\n  metrics: PerformanceMetric[];\n  userAgent: string;\n  connection?: {\n    effectiveType?: string;\n    downlink?: number;\n    rtt?: number;\n  };\n}\n\nclass PerformanceMonitor {\n  private metrics: Map<string, PerformanceMetric> = new Map();\n  private observers: PerformanceObserver[] = [];\n  private reportingEndpoint?: string;\n\n  constructor(reportingEndpoint?: string) {\n    this.reportingEndpoint = reportingEndpoint;\n    this.initializeWebVitals();\n    this.initializeResourceTiming();\n    this.initializeNavigationTiming();\n  }\n\n  private initializeWebVitals() {\n    const handleMetric = (metric: PerformanceMetric) => {\n      this.metrics.set(metric.name, metric);\n      console.log(`ðŸŽ¯ ${metric.name}:`, {\n        value: `${metric.value}ms`,\n        rating: metric.rating,\n        delta: `${metric.delta}ms`\n      });\n      this.reportMetric(metric);\n    };\n\n    // Core Web Vitals\n    getCLS(handleMetric);\n    getFID(handleMetric);\n    getFCP(handleMetric);\n    getLCP(handleMetric);\n    getTTFB(handleMetric);\n  }\n\n  private initializeResourceTiming() {\n    if ('PerformanceObserver' in window) {\n      const observer = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'resource') {\n            this.analyzeResourcePerformance(entry as PerformanceResourceTiming);\n          }\n        }\n      });\n\n      try {\n        observer.observe({ entryTypes: ['resource'] });\n        this.observers.push(observer);\n      } catch (e) {\n        console.warn('Resource timing observer not supported');\n      }\n    }\n  }\n\n  private initializeNavigationTiming() {\n    if ('PerformanceObserver' in window) {\n      const observer = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'navigation') {\n            this.analyzeNavigationPerformance(entry as PerformanceNavigationTiming);\n          }\n        }\n      });\n\n      try {\n        observer.observe({ entryTypes: ['navigation'] });\n        this.observers.push(observer);\n      } catch (e) {\n        console.warn('Navigation timing observer not supported');\n      }\n    }\n  }\n\n  private analyzeResourcePerformance(entry: PerformanceResourceTiming) {\n    const loadTime = entry.responseEnd - entry.startTime;\n    const resourceType = this.getResourceType(entry.name);\n\n    // Log slow resources (> 1s)\n    if (loadTime > 1000) {\n      console.warn(`ðŸŒ Slow ${resourceType}:`, {\n        url: entry.name,\n        loadTime: `${loadTime.toFixed(2)}ms`,\n        size: `${entry.transferSize} bytes`\n      });\n    }\n\n    // Track API calls specifically\n    if (entry.name.includes('/api/')) {\n      const metric: PerformanceMetric = {\n        name: `API: ${entry.name.split('/api/')[1]}`,\n        value: loadTime,\n        delta: loadTime,\n        id: entry.name,\n        rating: loadTime > 1000 ? 'poor' : loadTime > 500 ? 'needs-improvement' : 'good'\n      };\n      \n      this.metrics.set(`api-${entry.name}`, metric);\n      console.log(`ðŸ“¡ API Call:`, {\n        endpoint: entry.name,\n        duration: `${loadTime.toFixed(2)}ms`,\n        rating: metric.rating\n      });\n    }\n  }\n\n  private analyzeNavigationPerformance(entry: PerformanceNavigationTiming) {\n    const metrics = {\n      dns: entry.domainLookupEnd - entry.domainLookupStart,\n      tcp: entry.connectEnd - entry.connectStart,\n      ssl: entry.secureConnectionStart > 0 ? entry.connectEnd - entry.secureConnectionStart : 0,\n      ttfb: entry.responseStart - entry.requestStart,\n      download: entry.responseEnd - entry.responseStart,\n      domProcessing: entry.domComplete - entry.domLoading,\n      total: entry.loadEventEnd - entry.navigationStart\n    };\n\n    console.log('ðŸš€ Navigation Performance:', {\n      DNS: `${metrics.dns.toFixed(2)}ms`,\n      TCP: `${metrics.tcp.toFixed(2)}ms`,\n      SSL: `${metrics.ssl.toFixed(2)}ms`,\n      TTFB: `${metrics.ttfb.toFixed(2)}ms`,\n      Download: `${metrics.download.toFixed(2)}ms`,\n      'DOM Processing': `${metrics.domProcessing.toFixed(2)}ms`,\n      Total: `${metrics.total.toFixed(2)}ms`\n    });\n  }\n\n  private getResourceType(url: string): string {\n    if (url.includes('.js')) return 'JavaScript';\n    if (url.includes('.css')) return 'CSS';\n    if (url.includes('.png') || url.includes('.jpg') || url.includes('.svg')) return 'Image';\n    if (url.includes('/api/')) return 'API';\n    if (url.includes('.woff') || url.includes('.ttf')) return 'Font';\n    return 'Other';\n  }\n\n  private reportMetric(metric: PerformanceMetric) {\n    if (this.reportingEndpoint) {\n      const data: PerformanceData = {\n        url: window.location.href,\n        timestamp: Date.now(),\n        metrics: [metric],\n        userAgent: navigator.userAgent,\n        connection: this.getConnectionInfo()\n      };\n\n      // Send to analytics endpoint (non-blocking)\n      fetch(this.reportingEndpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(data),\n        keepalive: true\n      }).catch(err => console.warn('Failed to report metric:', err));\n    }\n  }\n\n  private getConnectionInfo() {\n    const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection;\n    return connection ? {\n      effectiveType: connection.effectiveType,\n      downlink: connection.downlink,\n      rtt: connection.rtt\n    } : undefined;\n  }\n\n  // Public API\n  public measureOperation<T>(name: string, operation: () => T | Promise<T>): T | Promise<T> {\n    const start = performance.now();\n    \n    const finish = (result: T) => {\n      const duration = performance.now() - start;\n      const metric: PerformanceMetric = {\n        name: `Custom: ${name}`,\n        value: duration,\n        delta: duration,\n        id: name,\n        rating: duration > 1000 ? 'poor' : duration > 500 ? 'needs-improvement' : 'good'\n      };\n      \n      this.metrics.set(name, metric);\n      console.log(`â±ï¸  ${name}:`, `${duration.toFixed(2)}ms`);\n      return result;\n    };\n\n    try {\n      const result = operation();\n      \n      if (result instanceof Promise) {\n        return result.then(finish);\n      }\n      \n      return finish(result);\n    } catch (error) {\n      const duration = performance.now() - start;\n      console.error(`âŒ ${name} failed after ${duration.toFixed(2)}ms:`, error);\n      throw error;\n    }\n  }\n\n  public getMetrics(): PerformanceMetric[] {\n    return Array.from(this.metrics.values());\n  }\n\n  public getMetric(name: string): PerformanceMetric | undefined {\n    return this.metrics.get(name);\n  }\n\n  public clearMetrics(): void {\n    this.metrics.clear();\n  }\n\n  public generateReport(): PerformanceData {\n    return {\n      url: window.location.href,\n      timestamp: Date.now(),\n      metrics: this.getMetrics(),\n      userAgent: navigator.userAgent,\n      connection: this.getConnectionInfo()\n    };\n  }\n\n  public destroy(): void {\n    this.observers.forEach(observer => observer.disconnect());\n    this.observers.length = 0;\n    this.metrics.clear();\n  }\n}\n\n// React hook for performance monitoring\nexport const usePerformanceMonitor = (enabled = true) => {\n  const [monitor] = React.useState(() => {\n    if (!enabled || typeof window === 'undefined') return null;\n    return new PerformanceMonitor();\n  });\n\n  React.useEffect(() => {\n    return () => {\n      monitor?.destroy();\n    };\n  }, [monitor]);\n\n  const measureOperation = React.useCallback(\n    <T>(name: string, operation: () => T | Promise<T>) => {\n      if (!monitor) return operation();\n      return monitor.measureOperation(name, operation);\n    },\n    [monitor]\n  );\n\n  return {\n    measureOperation,\n    getMetrics: () => monitor?.getMetrics() || [],\n    generateReport: () => monitor?.generateReport() || null\n  };\n};\n\n// Bundle analyzer helper\nexport const logBundleSize = () => {\n  if (typeof window !== 'undefined' && 'performance' in window) {\n    window.addEventListener('load', () => {\n      const resources = performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n      \n      const jsResources = resources.filter(r => r.name.includes('.js'));\n      const cssResources = resources.filter(r => r.name.includes('.css'));\n      \n      const totalJSSize = jsResources.reduce((sum, r) => sum + (r.transferSize || 0), 0);\n      const totalCSSSize = cssResources.reduce((sum, r) => sum + (r.transferSize || 0), 0);\n      \n      console.log('ðŸ“¦ Bundle Analysis:', {\n        'JavaScript': `${(totalJSSize / 1024).toFixed(2)} KB (${jsResources.length} files)`,\n        'CSS': `${(totalCSSSize / 1024).toFixed(2)} KB (${cssResources.length} files)`,\n        'Total': `${((totalJSSize + totalCSSSize) / 1024).toFixed(2)} KB`\n      });\n      \n      // Log largest resources\n      const largestResources = resources\n        .filter(r => r.transferSize > 0)\n        .sort((a, b) => (b.transferSize || 0) - (a.transferSize || 0))\n        .slice(0, 5);\n        \n      console.log('ðŸ” Largest Resources:');\n      largestResources.forEach((resource, index) => {\n        console.log(`${index + 1}. ${resource.name.split('/').pop()}: ${((resource.transferSize || 0) / 1024).toFixed(2)} KB`);\n      });\n    });\n  }\n};\n\n// Create global performance monitor instance\nconst globalMonitor = typeof window !== 'undefined' \n  ? new PerformanceMonitor() \n  : null;\n\nexport { PerformanceMonitor };\nexport default globalMonitor;\n\n// Initialize bundle size logging in development\nif (import.meta.env.DEV) {\n  logBundleSize();\n}